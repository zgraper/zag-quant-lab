"""
Statistical models module for ZAG Financial Lab.

This module implements Hidden Markov Models for market regime detection.
Uses Gaussian emission distributions to model different market states.
"""

import numpy as np
import pandas as pd
from hmmlearn import hmm
from typing import Tuple, Optional
import warnings


class GaussianRegimeDetector:
    """
    Gaussian Hidden Markov Model for market regime detection.
    
    This model assumes that market returns and volatility are generated by
    an underlying hidden Markov process with distinct states (regimes).
    Each regime has its own Gaussian distribution characteristics.
    
    Parameters
    ----------
    n_regimes : int, default=3
        Number of hidden states (market regimes) to detect
    n_iter : int, default=100
        Maximum number of iterations for EM algorithm
    random_state : int, optional
        Random seed for reproducibility
        
    Attributes
    ----------
    model_ : GaussianHMM
        Fitted HMM model
    is_fitted_ : bool
        Whether model has been fitted
        
    Notes
    -----
    This is a research tool for understanding market dynamics. It should not
    be used for trading decisions without extensive validation and risk management.
    """
    
    def __init__(
        self,
        n_regimes: int = 3,
        n_iter: int = 100,
        random_state: Optional[int] = None
    ):
        self.n_regimes = n_regimes
        self.n_iter = n_iter
        self.random_state = random_state
        self.model_ = None
        self.is_fitted_ = False
        
    def fit(self, X: np.ndarray) -> 'GaussianRegimeDetector':
        """
        Fit the Gaussian HMM to feature data.
        
        Parameters
        ----------
        X : np.ndarray, shape (n_samples, n_features)
            Feature matrix (typically returns and volatility)
            
        Returns
        -------
        self
            Fitted model
            
        Notes
        -----
        Uses Expectation-Maximization (EM) algorithm to find maximum likelihood
        estimates of model parameters. Convergence is not guaranteed.
        """
        # Initialize model
        self.model_ = hmm.GaussianHMM(
            n_components=self.n_regimes,
            covariance_type="full",
            n_iter=self.n_iter,
            random_state=self.random_state
        )
        
        # Suppress convergence warnings for cleaner output
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=RuntimeWarning)
            self.model_.fit(X)
        
        self.is_fitted_ = True
        return self
    
    def predict(self, X: np.ndarray) -> np.ndarray:
        """
        Predict most likely regime sequence using Viterbi algorithm.
        
        Parameters
        ----------
        X : np.ndarray, shape (n_samples, n_features)
            Feature matrix
            
        Returns
        -------
        np.ndarray, shape (n_samples,)
            Predicted regime labels (0 to n_regimes-1)
            
        Raises
        ------
        ValueError
            If model has not been fitted
        """
        if not self.is_fitted_:
            raise ValueError("Model must be fitted before prediction")
            
        return self.model_.predict(X)
    
    def predict_proba(self, X: np.ndarray) -> np.ndarray:
        """
        Calculate posterior probabilities of each regime at each time point.
        
        Parameters
        ----------
        X : np.ndarray, shape (n_samples, n_features)
            Feature matrix
            
        Returns
        -------
        np.ndarray, shape (n_samples, n_regimes)
            Posterior probability of each regime at each time point
            
        Raises
        ------
        ValueError
            If model has not been fitted
        """
        if not self.is_fitted_:
            raise ValueError("Model must be fitted before prediction")
            
        return self.model_.predict_proba(X)
    
    def get_regime_parameters(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        Get mean and covariance parameters for each regime.
        
        Returns
        -------
        tuple
            (means, covariances)
            - means: shape (n_regimes, n_features)
            - covariances: shape (n_regimes, n_features, n_features)
            
        Raises
        ------
        ValueError
            If model has not been fitted
        """
        if not self.is_fitted_:
            raise ValueError("Model must be fitted before accessing parameters")
            
        return self.model_.means_, self.model_.covars_
    
    def get_transition_matrix(self) -> np.ndarray:
        """
        Get estimated transition probability matrix.
        
        Returns
        -------
        np.ndarray, shape (n_regimes, n_regimes)
            Transition probabilities. Element [i, j] represents
            probability of transitioning from regime i to regime j
            
        Raises
        ------
        ValueError
            If model has not been fitted
        """
        if not self.is_fitted_:
            raise ValueError("Model must be fitted before accessing parameters")
            
        return self.model_.transmat_
